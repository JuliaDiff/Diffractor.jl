<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Diffractor</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Diffractor</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="reading_list.html">Reading List</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/Diffractor.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Diffractor"><a class="docs-heading-anchor" href="#Diffractor">Diffractor</a><a id="Diffractor-1"></a><a class="docs-heading-anchor-permalink" href="#Diffractor" title="Permalink"></a></h1><ul><li><a href="api.html#Diffractor.AbstractTangentBundle"><code>Diffractor.AbstractTangentBundle</code></a></li><li><a href="api.html#Diffractor.CompositeBundle"><code>Diffractor.CompositeBundle</code></a></li><li><a href="api.html#Diffractor.ExplicitTangent"><code>Diffractor.ExplicitTangent</code></a></li><li><a href="api.html#Diffractor.Jet"><code>Diffractor.Jet</code></a></li><li><a href="api.html#Diffractor.ProductTangent"><code>Diffractor.ProductTangent</code></a></li><li><a href="api.html#Diffractor.TangentBundle"><code>Diffractor.TangentBundle</code></a></li><li><a href="api.html#Diffractor.TaylorTangent"><code>Diffractor.TaylorTangent</code></a></li><li><a href="api.html#Diffractor.UniformTangent"><code>Diffractor.UniformTangent</code></a></li><li><a href="api.html#Diffractor.∂⃖"><code>Diffractor.∂⃖</code></a></li><li><a href="api.html#Diffractor.∂☆"><code>Diffractor.∂☆</code></a></li><li><a href="api.html#Diffractor.∇"><code>Diffractor.∇</code></a></li><li><a href="api.html#Diffractor.:&#39;-Tuple{Any}"><code>Diffractor.:&#39;</code></a></li><li><a href="api.html#Diffractor.dx-Tuple{Real}"><code>Diffractor.dx</code></a></li><li><a href="api.html#Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}"><code>Diffractor.forward_diff_no_inf!</code></a></li><li><a href="api.html#Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N"><code>Diffractor.jet_taylor_ev</code></a></li><li><a href="api.html#Diffractor.∂x-Tuple{Real}"><code>Diffractor.∂x</code></a></li><li><a href="api.html#Diffractor.@∂-Tuple{Any}"><code>Diffractor.@∂</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Diffractor.AbstractTangentBundle" href="#Diffractor.AbstractTangentBundle"><code>Diffractor.AbstractTangentBundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type TangentBundle{N, B}; end</code></pre><p>This type represents the <code>N</code>-th order (iterated) tangent bundle [1] <code>TⁿB</code> over some base (Riemannian) manifold <code>B</code>. Note that <code>TⁿB</code> is itself another manifold and thus in particular a vector space (over ℝ). As such, subtypes of this abstract type are expected to support the usual vector space operations.</p><p>However, beyond that, this abstract type makes no guarantee about the representation. That said, to gain intution for what this object is, it makes sense to pick some explicit bases and write down examples.</p><p>To that end, suppose that B=ℝ. Then <code>T¹B=T¹ℝ</code> is just our usual notion of a dual number, i.e. for some element <code>η ∈ T¹ℝ</code>, we may consider <code>η = a + bϵ</code> for real numbers <code>(a, b)</code> and <code>ϵ</code> an infinitessimal differential such that <code>ϵ^2 = 0</code>.</p><p>Equivalently, we may think of <code>η</code> as being identified with the vector <code>(a, b) ∈ ℝ²</code> with some additional structure. The same form essentially holds for general <code>B</code>, where we may write (as sets):</p><pre><code class="nohighlight hljs">T¹B = {(a, b) | a ∈ B, b ∈ Tₐ B }</code></pre><p>Note that these vectors are orthogonal to those in the underlying base space. For example, if <code>B=ℝ²</code>, then we have:</p><pre><code class="nohighlight hljs">T¹ℝ² = {([aₓ, a_y], [bₓ, b_y]) | [aₓ, a_y] ∈ ℝ², [bₓ, b_y] ∈ Tₐ ℝ² }</code></pre><p>For convenience, we will sometimes writes these in one as:</p><pre><code class="nohighlight hljs">η ∈ T ℝ²  = aₓ x̂ + a_y ŷ + bₓ ∂/∂x|_aₓ x + b_y ∂/∂y|_{a_y}
         := aₓ x̂ + a_y ŷ + bₓ ∂/∂¹x + b_y ∂/∂¹y
         := [aₓ, a_y] + [bₓ, b_y] ∂/∂¹
         := a + b ∂/∂¹
         := a + b ∂₁</code></pre><p>These are all definitional equivalences and we will mostly work with the final form. An important thing to keep in mind though is that the subscript on ∂₁ does not refer to a dimension of the underlying base manifold (for which we will rarely pick an explicit basis here), but rather tags the basis of the tangent bundle.</p><p>Let us iterate this construction to second order. We have:</p><pre><code class="nohighlight hljs">T²B = T¹(T¹B) = { (α, β) | α ∈ T¹B, β ∈ T_α T¹B }
              = { ((a, b), (c, d)) | a ∈ B, b ∈ Tₐ B, c ∈ Tₐ B, d ∈ T²ₐ B}</code></pre><p>(where in the last equality we used the linearity of the tangent vector).</p><p>Following our above notation, we will canonically write such an element as:</p><pre><code class="nohighlight hljs">  a + b ∂₁ + c ∂₂ + d ∂₂ ∂₁
= a + b ∂₁ + c ∂₂ + d ∂₁ ∂₂</code></pre><p>It is worth noting that there still only is one base point <code>a</code> of the underlying manifold and thus <code>TⁿB</code> is a vector bundle over <code>B</code> for all <code>N</code>.</p><p><strong>Further Reading</strong></p><p>[1] https://en.wikipedia.org/wiki/Tangent_bundle</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.CompositeBundle" href="#Diffractor.CompositeBundle"><code>Diffractor.CompositeBundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeBundle{N, B &lt;: Tuple}</code></pre><p>Represents the tagent bundle where the base space is some tuple or struct type. Mathematically, this tangent bundle is the product bundle of the individual element bundles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L285-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.ExplicitTangent" href="#Diffractor.ExplicitTangent"><code>Diffractor.ExplicitTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitTangent{P}</code></pre><p>A fully explicit coordinate representation of the tangent space, represented by a vector of <code>2^(N-1)</code> partials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.Jet" href="#Diffractor.Jet"><code>Diffractor.Jet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Jet{T, N}</code></pre><p>Represents the truncated (N-1)-th order Taylor series</p><pre><code class="nohighlight hljs">f(a) + (x-a)f&#39;(a) + 1/2(x-a)^2f&#39;&#39;(a) + ...</code></pre><p>Coefficients are stored in unscaled form. For a jet <code>j</code>, several operations are supported:</p><ol><li>Indexing <code>j[i]</code> returns fᵢ</li><li>Evaluation j(x) semantically evaluates the truncated taylor series at <code>x</code>. However, evaluation is restricted to be precisely at <code>a</code> - the additional information in the taylor series is only available through derivatives. Mathematically this corresponds to an infinitessimal ball around <code>a</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/jet.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.ProductTangent" href="#Diffractor.ProductTangent"><code>Diffractor.ProductTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProductTangent{T &lt;: Tuple{Vararg{AbstractTangentSpace}}}</code></pre><p>Represents the product space of the given representations of the tangent space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.TangentBundle" href="#Diffractor.TangentBundle"><code>Diffractor.TangentBundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TangentBundle{N, B, P}</code></pre><p>Represents a tangent bundle as an explicit primal together with some representation of (potentially a product of) the tangent space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.TaylorTangent" href="#Diffractor.TaylorTangent"><code>Diffractor.TaylorTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TaylorTangent{C}</code></pre><p>The taylor bundle construction mods out the full N-th order tangent bundle by the equivalence relation that coefficients of like-order basis elements be equal, i.e. rather than a generic element</p><pre><code class="nohighlight hljs">a + b ∂₁ + c ∂₂ + d ∂₃ + e ∂₂ ∂₁ + f ∂₃ ∂₁ + g ∂₃ ∂₂ + h ∂₃ ∂₂ ∂₁</code></pre><p>we have a tuple (c₀, c₁, c₂, c₃) corresponding to the full element</p><pre><code class="nohighlight hljs">c₀ + c₁ ∂₁ + c₁ ∂₂ + c₁ ∂₃ + c₂ ∂₂ ∂₁ + c₂ ∂₃ ∂₁ + c₂ ∂₃ ∂₂ + c₃ ∂₃ ∂₂ ∂₁</code></pre><p>i.e.</p><pre><code class="nohighlight hljs">c₀ + c₁ (∂₁ + ∂₂ + ∂₃) + c₂ (∂₂ ∂₁ + ∂₃ ∂₁ + ∂₃ ∂₂) + c₃ ∂₃ ∂₂ ∂₁</code></pre><p>This restriction forms a submanifold of the original manifold. The naming is by analogy with the (truncated) Taylor series</p><pre><code class="nohighlight hljs">c₀ + c₁ x + 1/2 c₂ x² + 1/3! c₃ x³ + O(x⁴)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L98-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.UniformTangent" href="#Diffractor.UniformTangent"><code>Diffractor.UniformTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UniformTangent</code></pre><p>Represents an N-th order tangent bundle with all unform partials. Particularly useful for representing singleton values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/tangent.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.∂⃖" href="#Diffractor.∂⃖"><code>Diffractor.∂⃖</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∂⃖{N}</code></pre><p>∂⃖{N} is the reverse-mode AD optic functor of order <code>N</code>. A call <code>(::∂⃖{N})(f, args...)</code> corresponds to  ∂⃖ⁿ f(args...) in the linear encoding of an N-optic (see the terminology guide for definitions of these terms).</p><p>In general <code>(::∂⃖{N})(f, args...)</code> will return a tuple of the original primal value <code>f(args...)</code> (in rare cases primitives may modify the primal value - in general we will ignore this rare complication for the purposes of clear documentation) and an optic continuation <code>λ</code>. The interpretation of this continuation depends on the order of the functor:</p><p>For example, ∂⃖{1} computes first derivatives. In particular, for a function <code>f</code>, <code>∂⃖{1}(f, args...)</code> will return the tuple <code>(f(args...), f⋆)</code> (read &quot;f upper-star&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.∂☆" href="#Diffractor.∂☆"><code>Diffractor.∂☆</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∂☆{N}</code></pre><p>∂☆{N} is the forward-mode AD functor of order <code>N</code>. A call <code>(::∂☆{N})(f, args...)</code> evaluating a function <code>f: A -&gt; B</code> is lifted to its pushforward on the N-th order tangent bundle <code>f⋆: Tⁿ A -&gt; Tⁿ B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.∇" href="#Diffractor.∇"><code>Diffractor.∇</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∇(f, args...)</code></pre><p>Computes the gradient ∇f(x, y, z...) (at (x, y, z...)). In particular, the return value will be a tuple of partial derivatives <code>(∂f/∂x, ∂f/∂y, ∂f/∂z...)</code>.</p><p><strong>Curried version</strong></p><p>Alternatively, ∇ may be curried, essentially giving the gradient as a function:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Diffractor: ∇

julia&gt; map(∇(*), (1,2,3), (4,5,6))
((4.0, 1.0), (5.0, 2.0), (6.0, 3.0))</code></pre><p><strong>The derivative ∂f/∂f</strong></p><p>Note that since in Julia, there is no distinction between functions and values, there is in principle a partial derivative with respect to the function itself. However, said partial derivative is dropped by this interface. It is however available using the lower level ∂⃖ if desired. This interaction can also be used to obtain gradients with respect to only some of the arguments by using a closure:</p><p>∇((x,z)-&gt;f(x,y,z))(x, z) # returns (∂f/∂x, ∂f/∂z)</p><p>Though of course the same can be obtained by simply indexing the resulting tuple (in well-inferred code there should not be a performance difference between these two options).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L79-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.:&#39;-Tuple{Any}" href="#Diffractor.:&#39;-Tuple{Any}"><code>Diffractor.:&#39;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f&#39;</code></pre><p>This is a convenience syntax for taking the derivative of a function f: ℝ -&gt; ℝ. In particular, for such a function f&#39;(x) will be the first derivative of <code>f</code> at <code>x</code> (and similar for <code>f&#39;&#39;(x)</code> and second derivatives and so on.)</p><p>Note that the syntax conflicts with the Base definition for the adjoint of a matrix and thus is not enabled by default. To use it, add the following to the top of your module:</p><pre><code class="language-julia hljs">using Diffractor: var&quot;&#39;&quot;</code></pre><p>It is also available using the @∂ macro:</p><pre><code class="language-julia hljs">@∂ f&#39;(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L198-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.dx-Tuple{Real}" href="#Diffractor.dx-Tuple{Real}"><code>Diffractor.dx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dx(x)</code></pre><p>dx represents the trival differential one-form of a one dimensional Riemannian manifold <code>M</code>. In particular, it is a section of the cotangent bundle of <code>M</code>, meaning it may be evaluted at a point <code>x</code> of <code>M</code> to obtain an element of the cotangent space <code>T*ₓ M</code> to <code>M</code> at <code>x</code>. We impose no restrictions on the representations of either the manifold itself or the cotangent space.</p><p>By default, the only implementation provided identifies T*ₓ ℝ ≃ ℝ, keeping watever type is used to represent ℝ. i.e.</p><pre><code class="language-julia hljs">dx(x::Real) = one(x)</code></pre><p>However, users may provide additional overloads for custom representations of one dimensional Riemannian manifolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L37-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}" href="#Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}"><code>Diffractor.forward_diff_no_inf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward_diff_no_inf!(ir::IRCode, to_diff::Vector{Pair{SSAValue,Int}}; visit_custom!, transform!)</code></pre><p>Internal method which generates the code for forward mode diffentiation</p><ul><li><p><code>ir</code> the IR being differnetation</p></li><li><p><code>to_diff</code>: collection of all SSA values for which the derivative is to be taken,            paired with the order (first deriviative, second derivative etc)</p></li><li><p><code>visit_custom!(ir::IRCode, stmt, order::Int, recurse::Bool) -&gt; Bool</code>:</p></li></ul><pre><code class="nohighlight hljs">	decides if the custom `transform!` should be applied to a `stmt` or not
	Default: `false` for all statements</code></pre><ul><li><code>transform!(ir::IRCode, ssa::SSAValue, order::Int)</code> mutates <code>ir</code> to do a custom tranformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/codegen/forward_demand.jl#L200-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N" href="#Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N"><code>Diffractor.jet_taylor_ev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jet_taylor_ev(::Val{}, jet, taylor)</code></pre><p>Generates a closed form arithmetic expression for the N-th component of the action of a 1d jet (of order at least N) on a maximally symmetric (i.e. taylor) tangent bundle element. In particular, if we represent both the <code>jet</code> and the <code>taylor</code> tangent bundle element by their associated canonical taylor series:</p><pre><code class="nohighlight hljs">j = j₀ + j₁ (x - a) + j₂ 1/2 (x - a)^2 + ... + jₙ 1/n! (x - a)^n
t = t₀ + t₁ (x - t₀) + t₂ 1/2 (x - t₀)^2 + ... + tₙ 1/n! (x - t₀)^n</code></pre><p>then the action of evaluating <code>j</code> on <code>t</code>, is some other taylor series</p><pre><code class="nohighlight hljs">t′ = a + t′₁ (x - a) + t′₂ 1/2 (x - a)^2 + ... + t′ₙ 1/n! (x - a)^n</code></pre><p>The t′ᵢ can be found by explicitly plugging in <code>t</code> for every <code>x</code> and expanding out, dropping terms of orders that are higher. This computes closed form expressions for the t′ᵢ that are hopefully easier on the compiler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/jet.jl#L204-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.∂x-Tuple{Real}" href="#Diffractor.∂x-Tuple{Real}"><code>Diffractor.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x(x)</code></pre><p>For <code>x</code> in a one dimensional manifold, map x to the trivial, unital, 1st order tangent bundle. It should hold that <code>∀x ⟨∂x(x), dx(x)⟩ = 1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Diffractor.@∂-Tuple{Any}" href="#Diffractor.@∂-Tuple{Any}"><code>Diffractor.@∂</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@∂</code></pre><p>Convenice macro for writing partial derivatives. E.g. The expression:</p><pre><code class="language-julia hljs">@∂ f(∂x, ∂y)</code></pre><p>Will compute the partial derivative ∂^2 f/∂x∂y at <code>(x, y)</code>`. And similarly</p><pre><code class="language-julia hljs">@∂ f(∂²x, ∂y)</code></pre><p>will compute the derivative <code>∂^3 f/∂x^2 ∂y</code> at <code>(x,y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/fb4e03d259446ed61be389b12b3331ed0ddc2428/src/interface.jl#L220-L236">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="reading_list.html">« Reading List</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Wednesday 17 May 2023 12:39">Wednesday 17 May 2023</span>. Using Julia version 1.10.0-DEV.1327.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
