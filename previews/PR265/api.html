<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Diffractor</title><meta name="title" content="API · Diffractor"/><meta property="og:title" content="API · Diffractor"/><meta property="twitter:title" content="API · Diffractor"/><meta name="description" content="Documentation for Diffractor."/><meta property="og:description" content="Documentation for Diffractor."/><meta property="twitter:description" content="Documentation for Diffractor."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Diffractor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="reading_list.html">Reading List</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDiff/Diffractor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDiff/Diffractor.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Diffractor"><a class="docs-heading-anchor" href="#Diffractor">Diffractor</a><a id="Diffractor-1"></a><a class="docs-heading-anchor-permalink" href="#Diffractor" title="Permalink"></a></h1><ul><li><a href="api.html#Diffractor.AbstractTangentBundle"><code>Diffractor.AbstractTangentBundle</code></a></li><li><a href="api.html#Diffractor.ExplicitTangent"><code>Diffractor.ExplicitTangent</code></a></li><li><a href="api.html#Diffractor.Jet"><code>Diffractor.Jet</code></a></li><li><a href="api.html#Diffractor.TangentBundle"><code>Diffractor.TangentBundle</code></a></li><li><a href="api.html#Diffractor.TaylorTangent"><code>Diffractor.TaylorTangent</code></a></li><li><a href="api.html#Diffractor.UniformTangent"><code>Diffractor.UniformTangent</code></a></li><li><a href="api.html#Diffractor.zero_bundle"><code>Diffractor.zero_bundle</code></a></li><li><a href="api.html#Diffractor.∂xⁿ"><code>Diffractor.∂xⁿ</code></a></li><li><a href="api.html#Diffractor.∂⃖"><code>Diffractor.∂⃖</code></a></li><li><a href="api.html#Diffractor.∂☆"><code>Diffractor.∂☆</code></a></li><li><a href="api.html#Diffractor.∇"><code>Diffractor.∇</code></a></li><li><a href="api.html#Diffractor.:&#39;-Tuple{Any}"><code>Diffractor.:&#39;</code></a></li><li><a href="api.html#Diffractor.bundle"><code>Diffractor.bundle</code></a></li><li><a href="api.html#Diffractor.destructure-Union{Tuple{Diffractor.TangentBundle{N, B, Diffractor.TaylorTangent{P}} where P}, Tuple{B}, Tuple{N}} where {N, B&lt;:Tuple}"><code>Diffractor.destructure</code></a></li><li><a href="api.html#Diffractor.dx-Tuple{Real}"><code>Diffractor.dx</code></a></li><li><a href="api.html#Diffractor.find_end_of_phi_block-Tuple{Core.Compiler.IRCode, Int64}"><code>Diffractor.find_end_of_phi_block</code></a></li><li><a href="api.html#Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}"><code>Diffractor.forward_diff_no_inf!</code></a></li><li><a href="api.html#Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N"><code>Diffractor.jet_taylor_ev</code></a></li><li><a href="api.html#Diffractor.@∂-Tuple{Any}"><code>Diffractor.@∂</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.AbstractTangentBundle" href="#Diffractor.AbstractTangentBundle"><code>Diffractor.AbstractTangentBundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTangentBundle{N, B}; end</code></pre><p>This type represents the <code>N</code>-th order (iterated) tangent bundle [1] <code>TⁿB</code> over some base (Riemannian) manifold <code>B</code>. Note that <code>TⁿB</code> is itself another manifold and thus in particular a vector space (over ℝ). As such, subtypes of this abstract type are expected to support the usual vector space operations.</p><p>However, beyond that, this abstract type makes no guarantee about the representation. That said, to gain intution for what this object is, it makes sense to pick some explicit bases and write down examples.</p><p>To that end, suppose that B=ℝ. Then <code>T¹B=T¹ℝ</code> is just our usual notion of a dual number, i.e. for some element <code>η ∈ T¹ℝ</code>, we may consider <code>η = a + bϵ</code> for real numbers <code>(a, b)</code> and <code>ϵ</code> an infinitessimal differential such that <code>ϵ^2 = 0</code>.</p><p>Equivalently, we may think of <code>η</code> as being identified with the vector <code>(a, b) ∈ ℝ²</code> with some additional structure. The same form essentially holds for general <code>B</code>, where we may write (as sets):</p><pre><code class="nohighlight hljs">T¹B = {(a, b) | a ∈ B, b ∈ Tₐ B }</code></pre><p>Note that these vectors are orthogonal to those in the underlying base space. For example, if <code>B=ℝ²</code>, then we have:</p><pre><code class="nohighlight hljs">T¹ℝ² = {([aₓ, a_y], [bₓ, b_y]) | [aₓ, a_y] ∈ ℝ², [bₓ, b_y] ∈ Tₐ ℝ² }</code></pre><p>For convenience, we will sometimes writes these in one as:</p><pre><code class="nohighlight hljs">η ∈ T ℝ²  = aₓ x̂ + a_y ŷ + bₓ ∂/∂x|_aₓ x + b_y ∂/∂y|_{a_y}
         := aₓ x̂ + a_y ŷ + bₓ ∂/∂¹x + b_y ∂/∂¹y
         := [aₓ, a_y] + [bₓ, b_y] ∂/∂¹
         := a + b ∂/∂¹
         := a + b ∂₁</code></pre><p>These are all definitional equivalences and we will mostly work with the final form. An important thing to keep in mind though is that the subscript on ∂₁ does not refer to a dimension of the underlying base manifold (for which we will rarely pick an explicit basis here), but rather tags the basis of the tangent bundle.</p><p>Let us iterate this construction to second order. We have:</p><pre><code class="nohighlight hljs">T²B = T¹(T¹B) = { (α, β) | α ∈ T¹B, β ∈ T_α T¹B }
              = { ((a, b), (c, d)) | a ∈ B, b ∈ Tₐ B, c ∈ Tₐ B, d ∈ T²ₐ B}</code></pre><p>(where in the last equality we used the linearity of the tangent vector).</p><p>Following our above notation, we will canonically write such an element as:</p><pre><code class="nohighlight hljs">  a + b ∂₁ + c ∂₂ + d ∂₂ ∂₁
= a + b ∂₁ + c ∂₂ + d ∂₁ ∂₂</code></pre><p>It is worth noting that there still only is one base point <code>a</code> of the underlying manifold and thus <code>TⁿB</code> is a vector bundle over <code>B</code> for all <code>N</code>.</p><p><strong>Further Reading</strong></p><p>[1] https://en.wikipedia.org/wiki/Tangent_bundle</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.ExplicitTangent" href="#Diffractor.ExplicitTangent"><code>Diffractor.ExplicitTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitTangent{P}</code></pre><p>A fully explicit coordinate representation of the tangent space, represented by a vector of <code>2^N-1</code> partials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.Jet" href="#Diffractor.Jet"><code>Diffractor.Jet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Jet{T, N}</code></pre><p>Represents the truncated (N-1)-th order Taylor series</p><pre><code class="nohighlight hljs">f(a) + (x-a)f&#39;(a) + 1/2(x-a)^2f&#39;&#39;(a) + ...</code></pre><p>Coefficients are stored in unscaled form. For a jet <code>j</code>, several operations are supported:</p><ol><li>Indexing <code>j[i]</code> returns fᵢ</li><li>Evaluation j(x) semantically evaluates the truncated taylor series at <code>x</code>. However, evaluation is restricted to be precisely at <code>a</code> - the additional information in the taylor series is only available through derivatives. Mathematically this corresponds to an infinitessimal ball around <code>a</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/jet.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.TangentBundle" href="#Diffractor.TangentBundle"><code>Diffractor.TangentBundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TangentBundle{N, B, P}</code></pre><p>Represents a tangent bundle as an explicit primal together with some representation of the tangent space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.TaylorTangent" href="#Diffractor.TaylorTangent"><code>Diffractor.TaylorTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TaylorTangent{C}</code></pre><p>The taylor bundle construction mods out the full N-th order tangent bundle by the equivalence relation that coefficients of like-order basis elements be equal, i.e. rather than a generic element</p><pre><code class="nohighlight hljs">a + b ∂₁ + c ∂₂ + d ∂₃ + e ∂₂ ∂₁ + f ∂₃ ∂₁ + g ∂₃ ∂₂ + h ∂₃ ∂₂ ∂₁</code></pre><p>we have a tuple (c₀, c₁, c₂, c₃) corresponding to the full element</p><pre><code class="nohighlight hljs">c₀ + c₁ ∂₁ + c₁ ∂₂ + c₁ ∂₃ + c₂ ∂₂ ∂₁ + c₂ ∂₃ ∂₁ + c₂ ∂₃ ∂₂ + c₃ ∂₃ ∂₂ ∂₁</code></pre><p>i.e.</p><pre><code class="nohighlight hljs">c₀ + c₁ (∂₁ + ∂₂ + ∂₃) + c₂ (∂₂ ∂₁ + ∂₃ ∂₁ + ∂₃ ∂₂) + c₃ ∂₃ ∂₂ ∂₁</code></pre><p>This restriction forms a submanifold of the original manifold. The naming is by analogy with the (truncated) Taylor series</p><pre><code class="nohighlight hljs">c₀ + c₁ x + 1/2 c₂ x² + 1/3! c₃ x³ + O(x⁴)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L107-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.UniformTangent" href="#Diffractor.UniformTangent"><code>Diffractor.UniformTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UniformTangent</code></pre><p>Represents an N-th order tangent bundle with all unform partials. Particularly useful for representing singleton values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.zero_bundle" href="#Diffractor.zero_bundle"><code>Diffractor.zero_bundle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(::zero_bundle{N})(primal)</code></pre><p>Creates a bundle with a zero tangent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L423-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.∂xⁿ" href="#Diffractor.∂xⁿ"><code>Diffractor.∂xⁿ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∂xⁿ{N}(x)</code></pre><p>For <code>x</code> in a one dimensional manifold, map x to the trivial, unital, Nth order tangent bundle. It should hold that <code>∀x ⟨∂ⁿ{1}x(x), dx(x)⟩ = 1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.∂⃖" href="#Diffractor.∂⃖"><code>Diffractor.∂⃖</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∂⃖{N}</code></pre><p>∂⃖{N} is the reverse-mode AD optic functor of order <code>N</code>. A call <code>(::∂⃖{N})(f, args...)</code> corresponds to  ∂⃖ⁿ f(args...) in the linear encoding of an N-optic (see the terminology guide for definitions of these terms).</p><p>In general <code>(::∂⃖{N})(f, args...)</code> will return a tuple of the original primal value <code>f(args...)</code> (in rare cases primitives may modify the primal value - in general we will ignore this rare complication for the purposes of clear documentation) and an optic continuation <code>λ</code>. The interpretation of this continuation depends on the order of the functor:</p><p>For example, ∂⃖{1} computes first derivatives. In particular, for a function <code>f</code>, <code>∂⃖{1}(f, args...)</code> will return the tuple <code>(f(args...), f⋆)</code> (read &quot;f upper-star&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.∂☆" href="#Diffractor.∂☆"><code>Diffractor.∂☆</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∂☆{N}</code></pre><p>∂☆{N} is the forward-mode AD functor of order <code>N</code>. A call <code>(::∂☆{N})(f, args...)</code> evaluating a function <code>f: A -&gt; B</code> is lifted to its pushforward on the N-th order tangent bundle <code>f⋆: Tⁿ A -&gt; Tⁿ B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.∇" href="#Diffractor.∇"><code>Diffractor.∇</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">∇(f, args...)</code></pre><p>Computes the gradient ∇f(x, y, z...) (at (x, y, z...)). In particular, the return value will be a tuple of partial derivatives <code>(∂f/∂x, ∂f/∂y, ∂f/∂z...)</code>.</p><p><strong>Curried version</strong></p><p>Alternatively, ∇ may be curried, essentially giving the gradient as a function:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Diffractor: ∇

julia&gt; map(∇(*), (1,2,3), (4,5,6))
((4.0, 1.0), (5.0, 2.0), (6.0, 3.0))</code></pre><p><strong>The derivative ∂f/∂f</strong></p><p>Note that since in Julia, there is no distinction between functions and values, there is in principle a partial derivative with respect to the function itself. However, said partial derivative is dropped by this interface. It is however available using the lower level ∂⃖ if desired. This interaction can also be used to obtain gradients with respect to only some of the arguments by using a closure:</p><p>∇((x,z)-&gt;f(x,y,z))(x, z) # returns (∂f/∂x, ∂f/∂z)</p><p>Though of course the same can be obtained by simply indexing the resulting tuple (in well-inferred code there should not be a performance difference between these two options).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L76-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.:&#39;-Tuple{Any}" href="#Diffractor.:&#39;-Tuple{Any}"><code>Diffractor.:&#39;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f&#39;</code></pre><p>This is a convenience syntax for taking the derivative of a function f: ℝ -&gt; ℝ. In particular, for such a function f&#39;(x) will be the first derivative of <code>f</code> at <code>x</code> (and similar for <code>f&#39;&#39;(x)</code> and second derivatives and so on.)</p><p>Note that the syntax conflicts with the Base definition for the adjoint of a matrix and thus is not enabled by default. To use it, add the following to the top of your module:</p><pre><code class="language-julia hljs">using Diffractor: var&quot;&#39;&quot;</code></pre><p>It is also available using the @∂ macro:</p><pre><code class="language-julia hljs">@∂ f&#39;(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L184-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.bundle" href="#Diffractor.bundle"><code>Diffractor.bundle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bundle(primal, tangent)</code></pre><p>Wraps a primal up with a tangent into the appropriate kind of <code>AbstractBundle{1}</code>. This is more or less the Diffractor equivelent of ForwardDiff.jl&#39;s <code>Dual</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/AbstractDifferentiation.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.destructure-Union{Tuple{Diffractor.TangentBundle{N, B, Diffractor.TaylorTangent{P}} where P}, Tuple{B}, Tuple{N}} where {N, B&lt;:Tuple}" href="#Diffractor.destructure-Union{Tuple{Diffractor.TangentBundle{N, B, Diffractor.TaylorTangent{P}} where P}, Tuple{B}, Tuple{N}} where {N, B&lt;:Tuple}"><code>Diffractor.destructure</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for a TaylorTangent{N, &lt;:Tuple} this breaks it up unto 1 TaylorTangent{N} for each element of the primal tuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/tangent.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.dx-Tuple{Real}" href="#Diffractor.dx-Tuple{Real}"><code>Diffractor.dx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dx(x)</code></pre><p>dx represents the trival differential one-form of a one dimensional Riemannian manifold <code>M</code>. In particular, it is a section of the cotangent bundle of <code>M</code>, meaning it may be evaluted at a point <code>x</code> of <code>M</code> to obtain an element of the cotangent space <code>T*ₓ M</code> to <code>M</code> at <code>x</code>. We impose no restrictions on the representations of either the manifold itself or the cotangent space.</p><p>By default, the only implementation provided identifies T*ₓ ℝ ≃ ℝ, keeping watever type is used to represent ℝ. i.e.</p><pre><code class="language-julia hljs">dx(x::Real) = one(x)</code></pre><p>However, users may provide additional overloads for custom representations of one dimensional Riemannian manifolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L37-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.find_end_of_phi_block-Tuple{Core.Compiler.IRCode, Int64}" href="#Diffractor.find_end_of_phi_block-Tuple{Core.Compiler.IRCode, Int64}"><code>Diffractor.find_end_of_phi_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_end_of_phi_block(ir::IRCode, start_search_idx::Int)</code></pre><p>Finds the last index within the same basic block, on or after the <code>start_search_idx</code> which is not within a phi block. A phi-block is a run on PhiNodes or nothings that must be the first statements within the basic block.</p><p>If <code>start_search_idx</code> is not within a phi block to begin with, then just returns <code>start_search_idx</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/stage1/compiler_utils.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}" href="#Diffractor.forward_diff_no_inf!-Tuple{Core.Compiler.IRCode, Vector{Pair{Core.SSAValue, Int64}}}"><code>Diffractor.forward_diff_no_inf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward_diff_no_inf!(ir::IRCode, to_diff::Vector{Pair{SSAValue,Int}}; visit_custom!, transform!)</code></pre><p>Internal method which generates the code for forward mode diffentiation</p><ul><li><p><code>ir</code> the IR being differnetation</p></li><li><p><code>to_diff</code>: collection of all SSA values for which the derivative is to be taken,            paired with the order (first deriviative, second derivative etc)</p></li><li><p><code>visit_custom!(ir::IRCode, ssa, order::Int, recurse::Bool) -&gt; Bool</code>:</p></li></ul><pre><code class="nohighlight hljs">	decides if the custom `transform!` should be applied to a `stmt` or not
	Default: `false` for all statements</code></pre><ul><li><code>transform!(ir::IRCode, ssa::SSAValue, order::Int)</code> mutates <code>ir</code> to do a custom tranformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/codegen/forward_demand.jl#L201-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N" href="#Diffractor.jet_taylor_ev-Union{Tuple{N}, Tuple{Val{N}, Any, Any}} where N"><code>Diffractor.jet_taylor_ev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jet_taylor_ev(::Val{}, jet, taylor)</code></pre><p>Generates a closed form arithmetic expression for the N-th component of the action of a 1d jet (of order at least N) on a maximally symmetric (i.e. taylor) tangent bundle element. In particular, if we represent both the <code>jet</code> and the <code>taylor</code> tangent bundle element by their associated canonical taylor series:</p><pre><code class="nohighlight hljs">j = j₀ + j₁ (x - a) + j₂ 1/2 (x - a)^2 + ... + jₙ 1/n! (x - a)^n
t = t₀ + t₁ (x - t₀) + t₂ 1/2 (x - t₀)^2 + ... + tₙ 1/n! (x - t₀)^n</code></pre><p>then the action of evaluating <code>j</code> on <code>t</code>, is some other taylor series</p><pre><code class="nohighlight hljs">t′ = a + t′₁ (x - a) + t′₂ 1/2 (x - a)^2 + ... + t′ₙ 1/n! (x - a)^n</code></pre><p>The t′ᵢ can be found by explicitly plugging in <code>t</code> for every <code>x</code> and expanding out, dropping terms of orders that are higher. This computes closed form expressions for the t′ᵢ that are hopefully easier on the compiler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/jet.jl#L204-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Diffractor.@∂-Tuple{Any}" href="#Diffractor.@∂-Tuple{Any}"><code>Diffractor.@∂</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@∂</code></pre><p>Convenice macro for writing partial derivatives. E.g. The expression:</p><pre><code class="language-julia hljs">@∂ f(∂x, ∂y)</code></pre><p>Will compute the partial derivative ∂^2 f/∂x∂y at <code>(x, y)</code>`. And similarly</p><pre><code class="language-julia hljs">@∂ f(∂²x, ∂y)</code></pre><p>will compute the derivative <code>∂^3 f/∂x^2 ∂y</code> at <code>(x,y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/Diffractor.jl/blob/bf9c29f249d4a8189141d7466ac681f46aa56520/src/interface.jl#L206-L222">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="reading_list.html">« Reading List</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 9 February 2024 00:36">Friday 9 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
